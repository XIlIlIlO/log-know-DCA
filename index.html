<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCA Log Analyzer (Pure JS)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen p-6 font-sans">

    <div class="max-w-3xl mx-auto bg-slate-800 rounded-2xl shadow-2xl border border-slate-700 p-8">
        <header class="text-center mb-10">
            <h1 class="text-3xl font-black bg-gradient-to-r from-cyan-400 to-blue-500 bg-clip-text text-transparent inline-block">
                DCA BACKTEST ANALYZER
            </h1>
            <p class="text-slate-400 mt-2 text-sm">파이썬 설치 없이 브라우저에서 바로 분석 (Pure JS)</p>
        </header>

        <div class="relative border-2 border-dashed border-slate-600 rounded-xl p-10 hover:border-cyan-500 transition-all group text-center mb-6">
            <input type="file" id="fileInput" multiple accept=".log" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
            <div class="pointer-events-none">
                <svg class="mx-auto h-12 w-12 text-slate-500 group-hover:text-cyan-400 transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
                <p class="mt-4 text-lg font-medium">로그 파일들을 여기에 드래그하거나 클릭하세요</p>
                <p id="fileNames" class="mt-2 text-sm text-slate-500 italic">선택된 파일 없음</p>
            </div>
        </div>

        <button id="processBtn" class="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-4 rounded-xl shadow-lg transition-all active:scale-[0.98] disabled:bg-slate-700 disabled:text-slate-500">
            분석 시작 및 엑셀 다운로드
        </button>

        <div id="status" class="mt-8 space-y-2 text-xs font-mono text-slate-400 max-h-48 overflow-y-auto"></div>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const fileNames = document.getElementById('fileNames');
        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');

        function addLog(msg, color = 'text-slate-400') {
            const p = document.createElement('p');
            p.className = color;
            p.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            statusDiv.prepend(p);
        }

        fileInput.onchange = () => {
            const files = fileInput.files;
            fileNames.textContent = files.length > 0 ? `${files.length}개의 파일 선택됨` : '선택된 파일 없음';
        };

        processBtn.onclick = async () => {
            const files = fileInput.files;
            if (files.length === 0) return alert('파일을 선택해주세요.');

            processBtn.disabled = true;
            addLog(`${files.length}개의 파일 처리 시작...`, 'text-cyan-400');

            for (const file of files) {
                try {
                    const text = await file.text();
                    const results = parseLog(text);
                    
                    if (results.length === 0) {
                        addLog(`${file.name}: 데이터 없음`, 'text-red-400');
                        continue;
                    }

                    generateExcel(results, file.name);
                    addLog(`${file.name}: 변환 완료`, 'text-green-400');
                } catch (err) {
                    addLog(`${file.name}: 에러 발생 - ${err.message}`, 'text-red-400');
                }
            }

            processBtn.disabled = false;
            addLog('모든 작업이 완료되었습니다.', 'text-cyan-400');
        };

        // 1. 로그 파싱 함수
        function parseLog(content) {
            // regex: □ PROFIT 블록 내부의 GROUP과 DCA 추출
            const regex = /□ PROFIT \[.*?\] .*? USDT\s*\n\s*\n- GROUP : (.*?)-\n- DCA : (\d+)\//g;
            const matches = [];
            let match;
            
            while ((match = regex.exec(content)) !== null) {
                matches.push({
                    group: match[1].trim(),
                    dca: parseInt(match[2])
                });
            }
            return matches;
        }

        // 2. 로그 스케일 색상 계산 함수
        function getLogColor(val, min, max) {
            if (val === 0) return { fill: { fgColor: { rgb: "FFFFFF" } }, font: { color: { rgb: "CCCCCC" } } };
            
            const logV = Math.log1p(val);
            const logMin = Math.log1p(min);
            const logMax = Math.log1p(max);
            
            let norm = (logMax === logMin) ? 1.0 : (logV - logMin) / (logMax - logMin);
            
            // 연두(E2F0D9) -> 빨강(FF7C80) 보간
            const r = Math.round(226 + (255 - 226) * norm);
            const g = Math.round(240 + (124 - 240) * norm);
            const b = Math.round(217 + (128 - 217) * norm);
            
            const hex = ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
            return {
                fill: { fgColor: { rgb: hex } },
                font: { color: { rgb: "000000" } },
                border: {
                    top: { style: "thin", color: { rgb: "FFFFFF" } },
                    bottom: { style: "thin", color: { rgb: "FFFFFF" } },
                    left: { style: "thin", color: { rgb: "FFFFFF" } },
                    right: { style: "thin", color: { rgb: "FFFFFF" } }
                }
            };
        }

        // 3. 엑셀 생성 및 다운로드 함수
        function generateExcel(data, originalFileName) {
            const groups = [...new Set(data.map(d => d.group))];
            const maxDca = Math.max(...data.map(d => d.dca));
            
            // 그룹별 총합 계산하여 내림차순 정렬 (가로축 정렬용)
            const groupTotals = {};
            groups.forEach(g => {
                groupTotals[g] = data.filter(d => d.group === g).length;
            });
            const sortedGroups = groups.sort((a, b) => groupTotals[b] - groupTotals[a]);

            // 헤더 작성 (A1은 공백, B1부터 그룹명)
            const header = ["DCA Step", ...sortedGroups];
            const rows = [header];

            // 데이터 행 작성 (0부터 maxDca까지 빠짐없이)
            for (let d = 0; d <= maxDca; d++) {
                const row = [`${d} DCA`];
                sortedGroups.forEach(g => {
                    const count = data.filter(item => item.group === g && item.dca === d).length;
                    row.push(count);
                });
                rows.push(row);
            }

            // 워크북 생성
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(rows);

            // 스타일 적용을 위한 데이터 범위 파악
            const countsOnly = data.map(d => d.dca); // 실제 수치들
            // 0이 아닌 최소값과 최대값 찾기
            const allCounts = [];
            for(let i=1; i < rows.length; i++) {
                for(let j=1; j < rows[i].length; j++) {
                    if(rows[i][j] > 0) allCounts.push(rows[i][j]);
                }
            }
            const minVal = Math.min(...allCounts);
            const maxVal = Math.max(...allCounts);

            // 셀 스타일 입히기
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let R = range.s.r; R <= range.e.r; ++R) {
                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const cellRef = XLSX.utils.encode_cell({ r: R, c: C });
                    if (!ws[cellRef]) continue;

                    // 헤더 스타일 (첫 행)
                    if (R === 0) {
                        ws[cellRef].s = {
                            fill: { fgColor: { rgb: "334155" } },
                            font: { color: { rgb: "FFFFFF" }, bold: true },
                            alignment: { horizontal: "center" }
                        };
                    } 
                    // 데이터 스타일 (첫 열 제외)
                    else if (C > 0) {
                        const val = ws[cellRef].v;
                        ws[cellRef].s = getLogColor(val, minVal, maxVal);
                        ws[cellRef].s.alignment = { horizontal: "center" };
                    }
                    // 첫 열 스타일 (DCA 차수)
                    else {
                        ws[cellRef].s = {
                            fill: { fgColor: { rgb: "F1F5F9" } },
                            font: { bold: true }
                        };
                    }
                }
            }

            XLSX.utils.book_append_sheet(wb, ws, "DCA Summary");
            
            // 파일 내보내기
            const outName = originalFileName.replace('.log', '_DCA_Summary.xlsx');
            XLSX.writeFile(wb, outName);
        }
    </script>
</body>
</html><!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DCA Log Analyzer (Pure JS)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen p-6 font-sans">

    <div class="max-w-3xl mx-auto bg-slate-800 rounded-2xl shadow-2xl border border-slate-700 p-8">
        <header class="text-center mb-10">
            <h1 class="text-3xl font-black bg-gradient-to-r from-cyan-400 to-blue-500 bg-clip-text text-transparent inline-block">
                DCA BACKTEST ANALYZER
            </h1>
            <p class="text-slate-400 mt-2 text-sm">파이썬 설치 없이 브라우저에서 바로 분석 (Pure JS)</p>
        </header>

        <div class="relative border-2 border-dashed border-slate-600 rounded-xl p-10 hover:border-cyan-500 transition-all group text-center mb-6">
            <input type="file" id="fileInput" multiple accept=".log" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
            <div class="pointer-events-none">
                <svg class="mx-auto h-12 w-12 text-slate-500 group-hover:text-cyan-400 transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
                <p class="mt-4 text-lg font-medium">로그 파일들을 여기에 드래그하거나 클릭하세요</p>
                <p id="fileNames" class="mt-2 text-sm text-slate-500 italic">선택된 파일 없음</p>
            </div>
        </div>

        <button id="processBtn" class="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-4 rounded-xl shadow-lg transition-all active:scale-[0.98] disabled:bg-slate-700 disabled:text-slate-500">
            분석 시작 및 엑셀 다운로드
        </button>

        <div id="status" class="mt-8 space-y-2 text-xs font-mono text-slate-400 max-h-48 overflow-y-auto"></div>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const fileNames = document.getElementById('fileNames');
        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');

        function addLog(msg, color = 'text-slate-400') {
            const p = document.createElement('p');
            p.className = color;
            p.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            statusDiv.prepend(p);
        }

        fileInput.onchange = () => {
            const files = fileInput.files;
            fileNames.textContent = files.length > 0 ? `${files.length}개의 파일 선택됨` : '선택된 파일 없음';
        };

        processBtn.onclick = async () => {
            const files = fileInput.files;
            if (files.length === 0) return alert('파일을 선택해주세요.');

            processBtn.disabled = true;
            addLog(`${files.length}개의 파일 처리 시작...`, 'text-cyan-400');

            for (const file of files) {
                try {
                    const text = await file.text();
                    const results = parseLog(text);
                    
                    if (results.length === 0) {
                        addLog(`${file.name}: 데이터 없음`, 'text-red-400');
                        continue;
                    }

                    generateExcel(results, file.name);
                    addLog(`${file.name}: 변환 완료`, 'text-green-400');
                } catch (err) {
                    addLog(`${file.name}: 에러 발생 - ${err.message}`, 'text-red-400');
                }
            }

            processBtn.disabled = false;
            addLog('모든 작업이 완료되었습니다.', 'text-cyan-400');
        };

        // 1. 로그 파싱 함수
        function parseLog(content) {
            // regex: □ PROFIT 블록 내부의 GROUP과 DCA 추출
            const regex = /□ PROFIT \[.*?\] .*? USDT\s*\n\s*\n- GROUP : (.*?)-\n- DCA : (\d+)\//g;
            const matches = [];
            let match;
            
            while ((match = regex.exec(content)) !== null) {
                matches.push({
                    group: match[1].trim(),
                    dca: parseInt(match[2])
                });
            }
            return matches;
        }

        // 2. 로그 스케일 색상 계산 함수
        function getLogColor(val, min, max) {
            if (val === 0) return { fill: { fgColor: { rgb: "FFFFFF" } }, font: { color: { rgb: "CCCCCC" } } };
            
            const logV = Math.log1p(val);
            const logMin = Math.log1p(min);
            const logMax = Math.log1p(max);
            
            let norm = (logMax === logMin) ? 1.0 : (logV - logMin) / (logMax - logMin);
            
            // 연두(E2F0D9) -> 빨강(FF7C80) 보간
            const r = Math.round(226 + (255 - 226) * norm);
            const g = Math.round(240 + (124 - 240) * norm);
            const b = Math.round(217 + (128 - 217) * norm);
            
            const hex = ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
            return {
                fill: { fgColor: { rgb: hex } },
                font: { color: { rgb: "000000" } },
                border: {
                    top: { style: "thin", color: { rgb: "FFFFFF" } },
                    bottom: { style: "thin", color: { rgb: "FFFFFF" } },
                    left: { style: "thin", color: { rgb: "FFFFFF" } },
                    right: { style: "thin", color: { rgb: "FFFFFF" } }
                }
            };
        }

        // 3. 엑셀 생성 및 다운로드 함수
        function generateExcel(data, originalFileName) {
            const groups = [...new Set(data.map(d => d.group))];
            const maxDca = Math.max(...data.map(d => d.dca));
            
            // 그룹별 총합 계산하여 내림차순 정렬 (가로축 정렬용)
            const groupTotals = {};
            groups.forEach(g => {
                groupTotals[g] = data.filter(d => d.group === g).length;
            });
            const sortedGroups = groups.sort((a, b) => groupTotals[b] - groupTotals[a]);

            // 헤더 작성 (A1은 공백, B1부터 그룹명)
            const header = ["DCA Step", ...sortedGroups];
            const rows = [header];

            // 데이터 행 작성 (0부터 maxDca까지 빠짐없이)
            for (let d = 0; d <= maxDca; d++) {
                const row = [`${d} DCA`];
                sortedGroups.forEach(g => {
                    const count = data.filter(item => item.group === g && item.dca === d).length;
                    row.push(count);
                });
                rows.push(row);
            }

            // 워크북 생성
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(rows);

            // 스타일 적용을 위한 데이터 범위 파악
            const countsOnly = data.map(d => d.dca); // 실제 수치들
            // 0이 아닌 최소값과 최대값 찾기
            const allCounts = [];
            for(let i=1; i < rows.length; i++) {
                for(let j=1; j < rows[i].length; j++) {
                    if(rows[i][j] > 0) allCounts.push(rows[i][j]);
                }
            }
            const minVal = Math.min(...allCounts);
            const maxVal = Math.max(...allCounts);

            // 셀 스타일 입히기
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let R = range.s.r; R <= range.e.r; ++R) {
                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const cellRef = XLSX.utils.encode_cell({ r: R, c: C });
                    if (!ws[cellRef]) continue;

                    // 헤더 스타일 (첫 행)
                    if (R === 0) {
                        ws[cellRef].s = {
                            fill: { fgColor: { rgb: "334155" } },
                            font: { color: { rgb: "FFFFFF" }, bold: true },
                            alignment: { horizontal: "center" }
                        };
                    } 
                    // 데이터 스타일 (첫 열 제외)
                    else if (C > 0) {
                        const val = ws[cellRef].v;
                        ws[cellRef].s = getLogColor(val, minVal, maxVal);
                        ws[cellRef].s.alignment = { horizontal: "center" };
                    }
                    // 첫 열 스타일 (DCA 차수)
                    else {
                        ws[cellRef].s = {
                            fill: { fgColor: { rgb: "F1F5F9" } },
                            font: { bold: true }
                        };
                    }
                }
            }

            XLSX.utils.book_append_sheet(wb, ws, "DCA Summary");
            
            // 파일 내보내기
            const outName = originalFileName.replace('.log', '_DCA_Summary.xlsx');
            XLSX.writeFile(wb, outName);
        }
    </script>
</body>
</html>
